package com.company ;

import java.util.*;
import java.util.regex.Pattern ;
import java.util.regex.Matcher ;

public class MathEvaluator {

    /**
     * Evaluate an input expression composed of numbers, the binary operators +, -, *, /,
     * and the unary operators + and -.
     * @param in_string
     * @return
     */
    public static double calculate(final String in_string) {

        // Maintains a parse stack, and a compute stack.
        // The top of the parse stack is the current parse tree node in a depth first search of the parse tree.
        // The input expression is converted to postfix, and the compute stack is used to compute the postfix expression.
        // This is an LL(1) parser, i.e. a top down predictive parser with one token of lookahead.

        final Deque<SymbolType> parseStack = new ArrayDeque<>() ;
        final Deque<Double> computeStack = new ArrayDeque<>() ;

        parseStack.push(SymbolType.END_OF_INPUT) ;
        parseStack.push(SymbolType.EXPRESSION) ;
        SymbolType peek_symbol_type ;
        final Tokenizer tokenizer = new Tokenizer(in_string) ;
        boolean is_unfinished_parse = true ;
        Symbol current_symbol = tokenizer.next() ;

        while (is_unfinished_parse) {

            peek_symbol_type = parseStack.peek() ;

            if (SymbolType.isNonTerminal(peek_symbol_type)) {
                // Pop the non-terminal at the top of the parse stack,
                // and push the RHS of the production onto the stack.
                // Don't push anything if the production is empty.
                parseStack.pop() ;
                final Map<SymbolType, SymbolType[]> row = ParseTable.parseTable.get(peek_symbol_type) ;
                if (row.containsKey(current_symbol.symbol_type)) {
                    final SymbolType[] terminal_children = row.get(current_symbol.symbol_type) ;
                    if (!(terminal_children.length == 1 && terminal_children[0] == SymbolType.NULL)) {
                        for(int i = terminal_children.length - 1 ; i != -1 ; --i) {
                            parseStack.push(terminal_children[i]) ;
                        }
                    }
                }
                else {
                    // No entry for the current non-terminal and current terminal,
                    // so the input string cannot be generated by the grammar.
                    Iterator<SymbolType> keys = row.keySet().iterator() ;
                    // Build error message containing expected terminals.
                    final StringBuilder sb = new StringBuilder() ;
                    sb.append("Got: ")
                            .append(current_symbol.symbol_type.toString())
                            .append(", but expected ")
                            .append(keys.next()) ;
                    while (keys.hasNext()) {
                        sb.append(", ").append(keys.next().toString()) ;
                    }
                    sb.append('.') ;
                    throw new RuntimeException(sb.toString()) ;
                }
            }
            else if (SymbolType.isTerminal(peek_symbol_type)) {
                if (current_symbol.symbol_type != peek_symbol_type) {
                    // Terminal at the top of the stack does not match the current terminal,
                    // so the input string cannot be generated by the grammar.
                    final String err_msg = new StringBuilder()
                            .append("Expected terminal ")
                            .append(peek_symbol_type.toString())
                            .append(" got")
                            .append(current_symbol.symbol_type.toString())
                            .toString() ;
                    throw new RuntimeException(err_msg) ;
                }
                if (current_symbol.symbol_type == SymbolType.NUMBER) {
                    computeStack.push(((Number)current_symbol).number) ;
                }
                else if (current_symbol.symbol_type == SymbolType.END_OF_INPUT && peek_symbol_type == SymbolType.END_OF_INPUT) {
                    break ;
                }
                parseStack.pop() ;
                current_symbol = tokenizer.next() ;
            }
            else if (SymbolType.isPostFixOperator(peek_symbol_type)) {
                // Update the compute stack by either pushing a number onto the stack,
                // or updating the value of the expression if peek_symbol_type (the terminal at the top of the parse
                // stack) is a post fix operator

                final double top_number = computeStack.pop() ;
                parseStack.pop() ;
                double first_number ;
                if (peek_symbol_type == SymbolType.UNARY_MINUS_PF) {
                    computeStack.push(-top_number) ;
                }
                else if (peek_symbol_type == SymbolType.UNARY_PLUS_PF) {
                    // A little yucky :|
                    computeStack.push(top_number) ;
                }
                else {

                    first_number = computeStack.pop() ;
                    switch (peek_symbol_type) {
                        case BINARY_PLUS_PF:
                            computeStack.push(first_number + top_number) ;
                            break ;
                        case BINARY_MINUS_PF:
                            computeStack.push(first_number - top_number) ;
                            break ;
                        case BINARY_TIMES_PF:
                            computeStack.push(first_number * top_number) ;
                            break ;
                        case BINARY_DIV_PF:
                            computeStack.push(first_number / top_number) ;
                            break ;
                        default:
                            assert false ;
                    }
                }
            }
            else {
                // SymbolType not classified as terminal, nonterminal, or postfix operator.
                assert false ;
            }
        }
        return computeStack.pop() ;
    }
}

enum SymbolType {
    UNARY_PLUS, UNARY_MINUS, BINARY_PLUS, BINARY_MINUS, BINARY_TIMES, BINARY_DIV,
    OPEN_PAREN, CLOSE_PAREN, NUMBER, NULL, END_OF_INPUT,
    EXPRESSION, TERM, MORE_TERMS, FACTOR, MORE_FACTORS,
    UNARY_PLUS_PF, UNARY_MINUS_PF, BINARY_PLUS_PF, BINARY_MINUS_PF, BINARY_TIMES_PF, BINARY_DIV_PF ;

    static boolean isTerminal(final SymbolType symbolType) {

        switch (symbolType) {
            case UNARY_PLUS:
            case BINARY_PLUS:
            case UNARY_MINUS:
            case BINARY_MINUS:
            case BINARY_TIMES:
            case BINARY_DIV:
            case OPEN_PAREN:
            case CLOSE_PAREN:
            case NUMBER:
            case NULL:
            case END_OF_INPUT:
                return true ;
            default:
                return false ;
        }
    }

    static boolean isNonTerminal(final SymbolType symbolType) {
        switch(symbolType) {
            case EXPRESSION:
            case TERM:
            case MORE_TERMS:
            case FACTOR:
            case MORE_FACTORS:
                return true ;
            default:
                return false ;
        }
    }

    static boolean isPostFixOperator(final SymbolType symbolType) {
        switch (symbolType) {
            case UNARY_PLUS_PF:
            case UNARY_MINUS_PF:
            case BINARY_PLUS_PF:
            case BINARY_MINUS_PF:
            case BINARY_TIMES_PF:
            case BINARY_DIV_PF:
                return true ;
            default:
                return false ;
        }
    }
}

/**
 *
 */
class Symbol {

    public final SymbolType symbol_type ;

    protected Symbol(final SymbolType symbol_type) {
        this.symbol_type = symbol_type ;
    }
}

class Terminal extends Symbol {

    protected Terminal(final SymbolType symbol_type) {
        super(symbol_type) ;
    }

    public static final char times_char = '*' ;
    public static final char div_char = '/' ;
    public static final char plus_char = '+' ;
    public static final char minus_char = '-' ;
    public static final char open_paren_char = '(' ;
    public static final char close_paren_char = ')' ;

    public static final Terminal binary_plus = new Terminal(SymbolType.BINARY_PLUS) ;
    public static final Terminal unary_plus = new Terminal(SymbolType.UNARY_PLUS) ;
    public static final Terminal binary_minus = new Terminal(SymbolType.BINARY_MINUS) ;
    public static final Terminal unary_minus = new Terminal(SymbolType.UNARY_MINUS) ;
    public static final Terminal binary_times = new Terminal(SymbolType.BINARY_TIMES) ;
    public static final Terminal binary_div = new Terminal(SymbolType.BINARY_DIV) ;
    public static final Terminal open_paren = new Terminal(SymbolType.OPEN_PAREN) ;
    public static final Terminal close_paren = new Terminal(SymbolType.CLOSE_PAREN) ;
    public static final Terminal none = new Terminal(SymbolType.NULL) ;
    public static final Terminal end_of_input = new Terminal(SymbolType.END_OF_INPUT) ;

}

class Number extends Terminal {
    public double number ;

    public Number(final String number) {
        super(SymbolType.NUMBER) ;
        this.number = Double.parseDouble(number) ;
    }

    public Number(final double number) {
        super(SymbolType.NUMBER) ;
        this.number = number ;
    }
}

/**
 * Split a string into tokens found in an expression.
 */
class Tokenizer implements Iterator<Symbol> {

    private static final String regular_expression = (new StringBuilder()).append("[()").append(Terminal.times_char).append(Terminal.div_char).append(Terminal.plus_char).append(Terminal.minus_char).append(']').append("|(\\.\\d+)|((\\d+)(\\.?\\d*)?)|(\\s+)").toString() ;
    private static final Pattern pattern = Pattern.compile(regular_expression) ;

    private final List<String> token_list ;
    private final Iterator<String> token_iterator ;
    private int token_i ;


    private static List<String> tokenize(final String in_string) {

        if (in_string.length() == 0) {
            throw new IllegalArgumentException("Cannot parse zero length input.") ;
        }

        List<String> token_list = new ArrayList<>() ;
        final Matcher matcher = pattern.matcher(in_string) ;
        boolean has_next = matcher.find() ;
        String token_string = "" ;
        int end = 0 ;
        while (has_next) {

            token_string = matcher.group() ;
            end = matcher.end() ;
            // By design, zero length match is impossible.
            assert token_string.length() != 0 ;

            if (!(token_string.charAt(0) == ' '
                    || token_string.charAt(0) == '\t'
                    || token_string.charAt(0) == '\n'
                    || token_string.charAt(0) == '\f'
                    || token_string.charAt(0) == '\r'
                    || token_string.charAt(0) == '\u000B')) {
                // \s	A whitespace character: [ \t\n\x0B\f\r]
                token_list.add(token_string) ;
            }
            has_next = end != in_string.length() && matcher.find() ;
        }

        if (end != in_string.length()) {
            final String err_message = new StringBuilder().append("Unrecognized character in input:").append(in_string.charAt(end)).toString() ;
            throw new IllegalArgumentException(err_message) ;
        }
        return token_list ;
    }

    /**
     * Tokenize input string.
     * Throws IllegalArgumentException if
     * @param in_string
     * @throws IllegalArgumentException
     */
    public Tokenizer(final String in_string) throws IllegalArgumentException {

        token_list = tokenize(in_string) ;
        token_iterator = token_list.iterator() ;
        token_i = 0 ;
    }

    /**
     * Return true if there is the Symbol in the sequence does not have SymbolType END_OF_INPUT.
     * Note: if hasNext() returns false, then next() returns Terminal.end_of_input.
     * @return
     */
    @Override
    public boolean hasNext() {
        return token_iterator.hasNext() ;
    }

    /**
     * Return the next Symbol in the sequence if there is one,
     * otherwise return Terminal.end_of_input.
     * @return
     */
    @Override
    public Symbol next() {

        if (!token_iterator.hasNext()) {
            return Terminal.end_of_input ;
        }
        final String token = token_iterator.next() ;

        Symbol nextSymbol = null ;
        switch (token.charAt(0)) {
            case Terminal.times_char:
                nextSymbol = Terminal.binary_times ;
                break ;
            case Terminal.div_char:
                nextSymbol = Terminal.binary_div ;
                break ;
            case Terminal.plus_char:
            case Terminal.minus_char:
                // Determine if the plus/minus character is a unary or binary operator by looking at the previous
                // Symbol.
                // Yucky redundant test on token.charAt(0)
                final boolean is_unary = token_i == 0
                        || token_list.get(token_i-1).charAt(0) == Terminal.times_char
                        || token_list.get(token_i-1).charAt(0) == Terminal.div_char
                        || token_list.get(token_i-1).charAt(0) == Terminal.plus_char
                        || token_list.get(token_i-1).charAt(0) == Terminal.minus_char
                        || token_list.get(token_i-1).charAt(0) == Terminal.open_paren_char ;
                nextSymbol = token.charAt(0) == Terminal.plus_char
                        ? (is_unary ? Terminal.unary_plus : Terminal.binary_plus)
                        : (is_unary ? Terminal.unary_minus : Terminal.binary_minus) ;
                break ;
            case Terminal.open_paren_char:
                nextSymbol = Terminal.open_paren ;
                break;
            case Terminal.close_paren_char:
                nextSymbol = Terminal.close_paren ;
                break;
            case '.':
            case '0':
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
                nextSymbol = new Number(token_list.get(token_i)) ;
                break;
            default:
                // You discovered a bug!
                assert false ;
        }
        ++token_i ;
        return nextSymbol ;
    }
}

class ParseTable {

    // parseTable maps a non terminal SymbolType to  M, where M maps a terminal SymbolType to the RHS of a
    // production, assuming such a production exists
    public static final Map<SymbolType, Map<SymbolType, SymbolType[]>> parseTable ;

    static {
        parseTable = new EnumMap<>(SymbolType.class);

        final SymbolType[]
                null_entry = {SymbolType.NULL},
                term_moreterms_entry = {SymbolType.TERM, SymbolType.MORE_TERMS},
                factor_morefactors_entry = {SymbolType.FACTOR, SymbolType.MORE_FACTORS};

        Map row = new EnumMap<SymbolType, SymbolType[]>(SymbolType.class);

        // expr ////////////////////////////////////////////////////////////////////////////
        // expr -> term more_terms
        row.put(SymbolType.UNARY_PLUS, term_moreterms_entry);
        row.put(SymbolType.UNARY_MINUS, term_moreterms_entry);
        row.put(SymbolType.NUMBER, term_moreterms_entry);
        row.put(SymbolType.OPEN_PAREN, term_moreterms_entry);
        parseTable.put(SymbolType.EXPRESSION, row);

        // more_terms //////////////////////////////////////////////////////////////////////
        // more_terms -> eps
        row = new EnumMap<SymbolType, SymbolType[]>(SymbolType.class);
        row.put(SymbolType.END_OF_INPUT, null_entry);
        row.put(SymbolType.CLOSE_PAREN, null_entry);

        // more_terms -> + term more_terms (+ term PF(+) more_terms)
        List<SymbolType> rowEntry = new ArrayList<>(4);
        row.put(SymbolType.BINARY_PLUS, new SymbolType[]{SymbolType.BINARY_PLUS, SymbolType.TERM, SymbolType.BINARY_PLUS_PF, SymbolType.MORE_TERMS});

        // more_terms -> - term more_terms (- term PF(-) more_terms)
        row.put(SymbolType.BINARY_MINUS, new SymbolType[]{SymbolType.BINARY_MINUS, SymbolType.TERM, SymbolType.BINARY_MINUS_PF, SymbolType.MORE_TERMS});
        parseTable.put(SymbolType.MORE_TERMS, row);

        // term ////////////////////////////////////////////////////////////////////////////
        // term -> factor more_factors
        row = new EnumMap<SymbolType, SymbolType[]>(SymbolType.class);
        row.put(SymbolType.UNARY_PLUS, factor_morefactors_entry);
        row.put(SymbolType.UNARY_MINUS, factor_morefactors_entry);
        row.put(SymbolType.NUMBER, factor_morefactors_entry);
        row.put(SymbolType.OPEN_PAREN, factor_morefactors_entry);
        parseTable.put(SymbolType.TERM, row) ;

        // more_factors ////////////////////////////////////////////////////////////////////////////
        row = new EnumMap<SymbolType, SymbolType[]>(SymbolType.class);
        row.put(SymbolType.END_OF_INPUT, null_entry);
        row.put(SymbolType.BINARY_PLUS, null_entry);
        row.put(SymbolType.BINARY_MINUS, null_entry);
        row.put(SymbolType.CLOSE_PAREN, null_entry);

        // more_factors -> * factor more_factors (* factor PF(*) more_factors)
        row.put(SymbolType.BINARY_TIMES, new SymbolType[]{SymbolType.BINARY_TIMES, SymbolType.FACTOR, SymbolType.BINARY_TIMES_PF, SymbolType.MORE_FACTORS});

        // more_factors -> * factor more_factors (/ factor PF(/) more_factors)
        row.put(SymbolType.BINARY_DIV, new SymbolType[]{SymbolType.BINARY_DIV, SymbolType.FACTOR, SymbolType.BINARY_DIV_PF, SymbolType.MORE_FACTORS});
        parseTable.put(SymbolType.MORE_FACTORS, row);

        // factor ////////////////////////////////////////////////////////////////////////////////////
        // factor -> - factor (factor -> - factor PF(-))
        row = new EnumMap<SymbolType, SymbolType[]>(SymbolType.class);
        row.put(SymbolType.UNARY_MINUS, new SymbolType[]{SymbolType.UNARY_MINUS, SymbolType.FACTOR, SymbolType.UNARY_MINUS_PF});

        // factor -> + factor (factor -> + factor PF(+))
        row.put(SymbolType.UNARY_PLUS, new SymbolType[]{SymbolType.UNARY_PLUS, SymbolType.FACTOR, SymbolType.UNARY_PLUS_PF});

        // factor -> number
        row.put(SymbolType.NUMBER, new SymbolType[]{SymbolType.NUMBER});

        // factor -> ( expr )
        row.put(SymbolType.OPEN_PAREN, new SymbolType[]{SymbolType.OPEN_PAREN, SymbolType.EXPRESSION, SymbolType.CLOSE_PAREN});

        parseTable.put(SymbolType.FACTOR, row);
    }
}
